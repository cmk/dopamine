{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE DeriveFunctor, RankNTypes #-}
{-# LANGUAGE TemplateHaskell , ExistentialQuantification           #-}

 {-# OPTIONS_GHC -w #-}
module Numeric.Ketamine.Effect.Ref where



--import Control.Lens (Lens', lens, view, iview)
--import Control.Lens.At (At(..), Index, IxValue)
import Control.Monad.IO.Class (MonadIO(..))
import Control.Monad.Reader (MonadReader(..))
import Control.Monad.Trans.Reader (ReaderT(..))
import Data.Void (Void)
--import UnliftIO

--import qualified Control.Lens as Lens
import Control.Lens
import Data.IORef
import Data.Tuple (swap)

{-
My state is just a big record with HasFoo, HasBar style classes generated by Lens (makeFields).

Then I have a newtype wrapper around StateT which derives MonadState and there's a custom instance of MonadReader for the same state.

I use a constraint alias like

type RW r w m = (MonadReader r m, MonadState w m)
and then my actions are typed according to what they need to read or write; something to read the current date and write to a log could have type

frob :: (HasDate read, HasLog write, RW read write m) => m ()
I think the pattern of using parametricity and field classes to do selective access is common, but I haven't seen the parallel Reader/State. In my application it's a very satisfactory solution.
-}

-- | Abstraction over how to read from and write to a mutable rference
--
data Ref a = forall r . Ref (IORef r) (Lens' r a)
--data Ref a b = forall s. Ref (IORef s) (Lens s s a b)
--
--These can be the same IORef when you want to be modifying one reference.
--data Ref a b = forall s t. Ref (IORef s) (IORef t) (Lens s t a b)

mapl :: Lens' a b -> Ref a -> Ref b
mapl  l' (Ref ref l) = Ref ref (l . l')

newRef :: a -> IO (Ref a)
newRef a = newIORef a >>= \r -> return (Ref r id)
   
readRef :: Ref a -> IO a
readRef (Ref b l) = view l <$> readIORef b

-- helper
atomicModifyIORef_ :: IORef a -> (a -> a) -> IO ()
atomicModifyIORef_ ref f = atomicModifyIORef ref (\a -> (f a, ()))

writeRef :: Ref a -> a -> IO ()
writeRef (Ref b l) a = atomicModifyIORef_ b (set l a)

modifyRef :: Ref a -> (a -> (a, r)) -> IO r
modifyRef (Ref r l) f = withLens l r f

modifyRef' :: Ref a -> (a -> (a, b)) -> IO b
modifyRef' (Ref b l) f = 
    atomicModifyIORef' b $
      \b' -> let (a, ret) = f (b' ^. l) in (set l a b', ret)

modifyRef_ :: Ref a -> (a -> a) -> IO ()
modifyRef_ (Ref b l) f = atomicModifyIORef_ b (over l f)

-- | Atomically modifies an 'IORef' using a lens
withLens :: Lens a a b c -> IORef a -> (b -> (c, r)) -> IO r
withLens l r f = atomicModifyIORef r (swap . traverseOf l (swap . f))


-- | Environment values with stateful capabilities.
--
class HasRef r e | e -> r where
    ref :: Lens' e (Ref r)


viewsRef :: (MonadReader s m, HasRef r s, MonadIO m) => (Ref r -> Ref b) -> m b
viewsRef f = views ref f >>= liftIO . readRef

viewRef :: (HasRef r e, MonadReader e m, MonadIO m) => m r
viewRef = viewsRef id

viewRefAt :: (At r, HasRef r e, MonadReader e m, MonadIO m) => Index r -> m (Maybe (IxValue r))
viewRefAt i = viewsRef $ mapl (at i)



--readRefAt :: (At r, HasRef r e, MonadReader e m, MonadIO m) => Index r -> m (Lens' m (Maybe (IxValue m)))

-- | apply the getter of the lens on the value of the IORef  
--getL :: IORef a -> Lens' a b -> IO b
--getL ref lens = mapIORef ref $ LE.getL lens

{-
readRefAt :: (At r, HasRef r e, MonadReader e m, MonadIO m) => Index r -> m (Lens' m (Maybe (IxValue m)))
readRefAt i = view ref >>= liftIO . readIORef

-- | apply the setter of the lens on the value of the IORef  
setL :: R.IORef a -> LE.Lens a b -> b -> IO ()
setL ref lens value = R.modifyIORef ref $ (LE.setL lens value)

-- | modify the value of the IORef with a lens
modL :: R.IORef a -> LE.Lens a b -> (b -> b) -> IO ()
modL ref lens f = R.modifyIORef ref $ LE.modL lens f

view (ref . to readIORef . at 0) im
-}

{-


Data.IORef.modifyIORef' :: IORef a -> (a -> a) -> IO ()
GHC.IORef.newIORef :: a -> IO (IORef a)
GHC.IORef.readIORef :: IORef a -> IO a
GHC.IORef.writeIORef :: IORef a -> a -> IO ()

type ScalarRef s = Ref Void s
--
-- | Read from a Ref
--
readRef :: MonadIO m => Ref k s -> k -> m s
readRef (Ref r _) k = liftIO $ r k

-- | Write to a Ref
--
writeRef :: MonadIO m => Ref k s -> k -> s -> m ()
writeRef (Ref _ w) k s = liftIO $ w k s

-- | Modify a Ref
-- This function is subject to change due to the lack of atomic operations
--
modifyRef :: MonadIO m => Ref k s -> k -> (s -> s) -> m ()
modifyRef (Ref r w) k f = liftIO $ fmap f (r k) >>= w k

toScalarRef :: IORef s -> Ref Void s
toScalarRef rf = do
    Ref (\_ -> readIORef rf)
            (\_ val -> modifyIORef' rf (\_ -> val))

-- | create a new boxed Ref
--
newScalarRef :: MonadIO m => s -> m (Ref Void s)
newScalarRef s = toScalarRef <$> newIORef s

-}

{-
--
-- | Read from a Ref
--
readRef :: MonadIO m => Ref a -> m a
readRef (Ref x _) = liftIO x

-- | Write to a Ref
--
writeRef :: MonadIO m => Ref a -> a -> m ()
writeRef (Ref _ x) = liftIO . x

-- | Modify a Ref
-- This function is subject to change due to the lack of atomic operations
--
modifyRef :: MonadIO m => Ref a -> (a -> a) -> m ()
modifyRef (Ref r w) f = liftIO $ fmap f r >>= w

ioRefToRef :: IORef a -> Ref a
ioRefToRef rf = do
    Ref (readIORef rf)
            (\val -> modifyIORef' rf (\_ -> val))

-- | create a new boxed Ref
--
newRef :: MonadIO m => a -> m (Ref a)
newRef a = do
    ioRefToRef <$> newIORef a
-}







