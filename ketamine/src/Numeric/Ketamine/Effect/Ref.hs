{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE LambdaCase, DeriveFunctor, RankNTypes #-}
{-# LANGUAGE TypeApplications, TemplateHaskell , ExistentialQuantification           #-}

 {-# OPTIONS_GHC -w #-}
-- | Environment values with stateful capabilities.
module Numeric.Ketamine.Effect.Ref where


import Numeric.Ketamine.Types
--import Control.Lens (Lens', lens, view, iview)
--import Control.Lens.At (At(..), Index, IxValue)
import Control.Monad.IO.Class (MonadIO(..))
import Control.Monad.Reader (MonadReader(..))
import Control.Monad.Trans.Reader (ReaderT(..))
import Data.Void (Void)
--import UnliftIO

--import qualified Control.Lens as Lens
import Control.Lens
import Data.IORef
import Data.Tuple (swap)
import Data.Either (either)
--import Unsafe.Coerce
{-
My state is just a big record with HasFoo, HasBar style classes generated by Lens (makeFields).

Then I have a newtype wrapper around StateT which derives MonadState and there's a custom instance of MonadReader for the same state.

I use a constraint alias like

type RW r w m = (MonadReader r m, MonadState w m)
and then my actions are typed according to what they need to read or write; something to read the current date and write to a log could have type

frob :: (HasDate read, HasLog write, RW read write m) => m ()
I think the pattern of using parametricity and field classes to do selective access is common, but I haven't seen the parallel Reader/State. In my application it's a very satisfactory solution.
-}
--data Ref a b = forall s. Ref (IORef s) (Lens s s a b)
--
--These can be the same IORef when you want to be modifying one reference.
--could extend to STRefs, MVars and TVars:
--http://hackage.haskell.org/package/global-variables-1.0.1.1/docs/Data-Global.html
--data Ref a b = forall s t. Ref (IORef s) (IORef t) (Lens s t a b)
--data Ref' i a b = forall s t. Ref' (IORef s) (IORef t) (IndexedLens i s t a b)
--mapl :: Lens' a b -> Ref a -> Ref b
--maplike :: ((a1 -> f a1) -> a2 -> f a2) -> Ref f a2 -> Ref f a1
{-
data Ref1 x f a = forall s . Ref1 (x s) (LensLike f s s a a)
type RRef1 x a = Ref1 x (Const a) a
type WRef1 x a = Ref1 x Identity a

type IOWRef1 a = WRef1 IORef a
--type LRef1 r a = forall f . Functor f => Ref1 r f a
type IORRef1 a = RRef1 IORef a
--LensLike (Const a) a a a a

--type STRef1 = Ref1 STRef
--type MVar1 = Ref1 MVar
maplike1 :: LensLike f a1 a1 a2 a2 -> Ref1 r f a1 -> Ref1 r f a2
maplike1 l = f $ traverseOf l
  where f l' (Ref1 ref l) = Ref1 ref (l . l')

instance Contravariant f => Functor (Ref1 r f) where
    fmap = maplike1 . to

maplike2 :: LensLike f a1 b1 a2 b2 -> Ref2 r f a1 b1 -> Ref2 r f a2 b2
maplike2 l = f $ traverseOf l
  where f l' (Ref2 r1 r2 l) = Ref2 r1 r2 (l . l')

--TODO grok behavior
modifyRef1' :: Ref1 IORef ((,) b) a -> (a -> (a, b)) -> IO b
modifyRef1' (Ref1 r l) f = atomicModifyIORef' r (swap . traverseOf l (swap . f))

modifyRef1 :: IOWRef1 a -> (a -> a) -> IO ()
modifyRef1 (Ref1 r l) f = modifyIORef r (over l f)

--r <- newIORRef1 1 (to (+1))
--n <- newIOWRef1 (1,2) _1
--n <- newIOLRef1 (1,2) _1
--
--sayref (Ref1 r _) = readIORef r

readIORef1 :: RRef1 IORef a -> IO a
readIORef1 (Ref1 r l) = view l <$> readIORef r

newIORef1' :: r -> IO (Ref1 IORef f r)
newIORef1' r = newIORef1 r id

--newRRef1 :: r -> IO (RRef1 IORef a)
newIORef1 :: s -> LensLike f s s a a -> IO (Ref1 IORef f a)
newIORef1 r g = newIORef r >>= \r' -> return (Ref1 r' g) 

--r <- newIORRef1 1 (to (+1))
newIORRef1 :: s -> LensLike (Const a) s s a a -> IO (RRef1 IORef a)
newIORRef1 = newIORef1

-- n <- newIOWRef1 (1,2) _1
newIOWRef1 :: s -> LensLike Identity s s a a -> IO (WRef1 IORef a)
newIOWRef1 = newIORef1
-}


data LRef' x a = forall s . LRef' (Lens' s a) (x s)

data PRef x a b = forall s t. PRef (Prism s t a b) (x s) (x t)

data PRef' x a = forall s. PRef' (Prism' s a) (x s)

newPRef :: s -> t -> Prism s t a b -> IO (PRef IORef a b)
newPRef s t p = (PRef p) <$> newIORef s <*> newIORef t 

--
--
newPRef' :: s -> Prism' s a -> IO (PRef' IORef a)
newPRef' s p = (PRef' p) <$> newIORef s 

--newLensRef :: PrimMonad m => s -> Lens s s a a -> m (RRef1 (PrimState m) a)
{-
s = Right "hi" :: Either Int String
t = Left 3 :: Either Int Int
p <- newPRef s t _Right
modifyPRef p length
readPRef p

s = Right 4 :: Either String Int
t = Right 3 :: Either Int Int

p <- newPRef' 4 $ only 4

(p' :: PRef IORef String Int) <- newPRef s t _Left

p :: PRef IORef String Int
modifyPRef p' length
-}
--withPrism :: APrism s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r

modifyPRef2 :: PRef IORef a b -> (a -> b) -> IO ()
modifyPRef2 (PRef p s t) f = foo =<< readIORef s
  where foo s' = withPrism p $ \bt seta -> either (writeIORef t) (writeIORef t . bt . f) (seta s')
{-
modifyPRef :: PRef IORef a a -> (a -> a) -> IO ()
modifyPRef (PRef p s _) f = foo =<< readIORef s
  where foo s' = withPrism p $ \bt seta -> either (writeIORef t) (writeIORef s . f) (seta s')
-}
--matching :: APrism s t a b -> s -> Either t a
--readPRef :: PRef IORef a b -> IO (Maybe a)
readPRef :: PRef IORef a b -> IO (Maybe a)
readPRef (PRef p s t) = foo <$> readIORef s
  where foo s' = withPrism p $ \_ seta -> either (\_ -> Nothing) Just (seta s')




--readPRef :: PRef IORef a b -> IO (Maybe a)
--readPRef' (PRef p s t) = foo <$> readIORef s where foo s' = withPrism p $ \_ seta -> (seta s')

newLRef' :: s -> Lens s s a a -> IO (LRef' IORef a)
newLRef' s l = newIORef s >>= \r -> return (LRef' l r) 

modifyLRef' :: LRef' IORef a -> (a -> a) -> IO ()
modifyLRef' (LRef' l r) f = modifyIORef r (over l f)

--readLRef' (LRef' l r) = view l <$> readIORef r

{-
--type Getting r s a = (a -> Const r a) -> s -> Const r s

-- | Abstraction over how to read from and write to a mutable rference
--
data Ref f a b = forall r . Ref (IORef r) (LensLike f r r a b)


type Ref' f a = Ref f a a
type LensRef a b = forall f . Functor f => Ref f a b
type LensRef' a = LensRef a a

type RRef a = Ref (Const a) a a
type WRef a b = Ref Identity a b
type MRef a b r = Ref ((,) r) a b


maplike :: LensLike f a1 b1 a2 b2 -> Ref f a1 b1 -> Ref f a2 b2
maplike l = f $ traverseOf l
  where f l' (Ref ref l) = Ref ref (l . l')

--modifyRef :: Ref ((,) r) a -> (a -> (a, r)) -> IO r
--ito :: (Indexable i p, Contravariant f) => (s -> (i, a)) -> Over' p f s a
ito' :: (Indexable i p, Contravariant f) => (s -> (a, i)) -> Over' p f s a
ito' = ito . (swap .)

foo :: Contravariant f => (b1 -> (a2, i)) -> Ref f b1 b1 -> Ref f a2 a2
foo = maplike . ito'

-- TODO make Ref an inst of Contravariant?
-- instance Contravariant f => Functor (Ref' f) where
bar :: Contravariant f => (a -> b) -> Ref' f a -> Ref' f b
bar = maplike . to

modifyRef :: MRef a b r -> (a -> (b, r)) -> IO r
modifyRef (Ref r l) f = atomicModifyIORef' r (swap . traverseOf l (swap . f))

newRef :: r -> IO (Ref f r r)
newRef r = newIORef r >>= \r' -> return (Ref r' id)

readRef :: RRef a -> IO a
readRef (Ref r l) = view l <$> readIORef r

writeRef :: WRef a b -> b -> IO ()
writeRef (Ref r l) a = atomicModifyIORef_ r (set l a)

atomicModifyIORef_ :: IORef a -> (a -> a) -> IO ()
atomicModifyIORef_ ref f = atomicModifyIORef' ref (\a -> (f a, ()))

viewsRef
  :: (Conf a r, MonadReader r m, MonadIO m)
  => (a -> RRef b) -> m b
viewsRef f = views conf f >>= liftIO . readRef

viewRefWith
  :: (Conf r1 r2, MonadReader r2 m, MonadIO m) => Getting (RRef b) r1 (RRef b) -> m b
viewRefWith l = view (conf . l) >>= liftIO . readRef

viewRef :: (Conf (RRef b) r, MonadReader r m, MonadIO m) => m b
viewRef = viewRefWith id

viewRefAt
  :: Conf (Ref (Const (Maybe (IxValue a))) a a) r
  => MonadReader r m
  => MonadIO m
  => At a
  => Index a -> m (Maybe (IxValue a))
viewRefAt i = viewsRef $ maplike (at i)

ixRef :: (Ixed a, Applicative f) => Index a -> Ref' f a -> Ref' f (IxValue a)
ixRef = maplike . ix

atRef :: (At a, Functor f) => Index a -> Ref' f a -> Ref' f (Maybe (IxValue a))
atRef = maplike . at

-}

{-
viewRefIxed
  :: Conf (Ref (Const (IxValue a)) a a) r
  => MonadReader r m
  => MonadIO m
  => Ixed a
  => Monoid (IxValue a) -- TODO ?
  => Index a -> m (IxValue a)
viewRefIxed i = viewsRef $ maplike (ix i)
-}
--overRef f = views conf f >>= liftIO . readRef


{-


Data.IORef.modifyIORef' :: IORef a -> (a -> a) -> IO ()
GHC.IORef.newIORef :: a -> IO (IORef a)
GHC.IORef.readIORef :: IORef a -> IO a
GHC.IORef.writeIORef :: IORef a -> a -> IO ()

type ScalarRef s = Ref Void s
--
-- | Read from a Ref
--
readRef :: MonadIO m => Ref k s -> k -> m s
readRef (Ref r _) k = liftIO $ r k

-- | Write to a Ref
--
writeRef :: MonadIO m => Ref k s -> k -> s -> m ()
writeRef (Ref _ w) k s = liftIO $ w k s

-- | Modify a Ref
-- This function is subject to change due to the lack of atomic operations
--
modifyRef :: MonadIO m => Ref k s -> k -> (s -> s) -> m ()
modifyRef (Ref r w) k f = liftIO $ fmap f (r k) >>= w k

toScalarRef :: IORef s -> Ref Void s
toScalarRef rf = do
    Ref (\_ -> readIORef rf)
            (\_ val -> modifyIORef' rf (\_ -> val))

-- | create a new boxed Ref
--
newScalarRef :: MonadIO m => s -> m (Ref Void s)
newScalarRef s = toScalarRef <$> newIORef s

-}

{-
--
-- | Read from a Ref
--
readRef :: MonadIO m => Ref a -> m a
readRef (Ref x _) = liftIO x

-- | Write to a Ref
--
writeRef :: MonadIO m => Ref a -> a -> m ()
writeRef (Ref _ x) = liftIO . x

-- | Modify a Ref
-- This function is subject to change due to the lack of atomic operations
--
modifyRef :: MonadIO m => Ref a -> (a -> a) -> m ()
modifyRef (Ref r w) f = liftIO $ fmap f r >>= w

ioRefToRef :: IORef a -> Ref a
ioRefToRef rf = do
    Ref (readIORef rf)
            (\val -> modifyIORef' rf (\_ -> val))

-- | create a new boxed Ref
--
newRef :: MonadIO m => a -> m (Ref a)
newRef a = do
    ioRefToRef <$> newIORef a
-}







